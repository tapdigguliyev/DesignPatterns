{
  "title": "Design Patterns",
  "patternTypes": [
    {
      "id": 1,
      "title": "Creational Patterns",
      "icon" : "https://vnfvnglfglbgblgmlb",
      "patterns": [
          {
            "id": 1,
            "title" :"Abstract Factory",
            "intent": "Provide an interface for creating families of related or dependent objects without specifying their concrete classes.\nA hierarchy that encapsulates: many possible 'platforms', and the construction of a suite of 'products'.\nThe new operator considered harmful.",
            "problem": "If an application is to be portable, it needs to encapsulate platform dependencies. These 'platforms' might include: windowing system, operating system, database, etc. Too often, this encapsulation is not engineered in advance, and lots of #ifdef case statements with options for all currently supported platforms begin to procreate like rabbits throughout the code.",
            "discussion": "Provide a level of indirection that abstracts the creation of families of related or dependent objects without directly specifying their concrete classes. The 'factory' object has the responsibility for providing creation services for the entire platform family. Clients never create platform objects directly, they ask the factory to do that for them.\n\nThis mechanism makes exchanging product families easy because the specific class of the factory object appears only once in the application - where it is instantiated. The application can wholesale replace the entire family of products simply by instantiating a different concrete instance of the abstract factory.\n\nBecause the service provided by the factory object is so pervasive, it is routinely implemented as a Singleton.",
            "structure": {
              "text": "The Abstract Factory defines a Factory Method per product. Each Factory Method encapsulates the new operator and the concrete, platform-specific, product classes. Each 'platform' is then modeled with a Factory derived class.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Abstract_Factory-2x.png"
            },
            "example": {
              "text": "The purpose of the Abstract Factory is to provide an interface for creating families of related objects, without specifying concrete classes. This pattern is found in the sheet metal stamping equipment used in the manufacture of Japanese automobiles. The stamping equipment is an Abstract Factory which creates auto body parts. The same machinery is used to stamp right hand doors, left hand doors, right front fenders, left front fenders, hoods, etc. for different models of cars. Through the use of rollers to change the stamping dies, the concrete classes produced by the machinery can be changed within three minutes.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Abstract_Factory_example1-2x.png"
            },
            "checkList": "Decide if 'platform independence' and creation services are the current source of pain.\nMap out a matrix of 'platforms' versus 'products'.\nDefine a factory interface that consists of a factory method per product.\nDefine a factory derived class for each platform that encapsulates all references to the new operator.\nThe client should retire all references to new, and use the factory methods to create the product objects.",
            "rulesOfThumb": "Sometimes creational patterns are competitors: there are cases when either Prototype or Abstract Factory could be used profitably. At other times they are complementary: Abstract Factory might store a set of Prototypes from which to clone and return product objects, Builder can use one of the other patterns to implement which components get built. Abstract Factory, Builder, and Prototype can use Singleton in their implementation.\nAbstract Factory, Builder, and Prototype define a factory object that's responsible for knowing and creating the class of product objects, and make it a parameter of the system. Abstract Factory has the factory object producing objects of several classes. Builder has the factory object building a complex product incrementally using a correspondingly complex protocol. Prototype has the factory object (aka prototype) building a product by copying a prototype object.\nAbstract Factory classes are often implemented with Factory Methods, but they can also be implemented using Prototype.\nAbstract Factory can be used as an alternative to Facade to hide platform-specific classes.\nBuilder focuses on constructing a complex object step by step. Abstract Factory emphasizes a family of product objects (either simple or complex). Builder returns the product as a final step, but as far as the Abstract Factory is concerned, the product gets returned immediately.\nOften, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed."
          },
          {
            "id": 2,
            "title" :"Builder",
            "intent": "Separate the construction of a complex object from its representation so that the same construction process can create different representations.\nParse a complex representation, create one of several targets.",
            "problem": "An application needs to create the elements of a complex aggregate. The specification for the aggregate exists on secondary storage and one of many representations needs to be built in primary storage.",
            "discussion": "Separate the algorithm for interpreting (i.e. reading and parsing) a stored persistence mechanism (e.g. RTF files) from the algorithm for building and representing one of many target products (e.g. ASCII, TeX, text widget). The focus/distinction is on creating complex aggregates.\n\nThe 'director' invokes 'builder' services as it interprets the external format. The 'builder' creates part of the complex object each time it is called and maintains all intermediate state. When the product is finished, the client retrieves the result from the 'builder'.\n\nAffords finer control over the construction process. Unlike creational patterns that construct products in one shot, the Builder pattern constructs the product step by step under the control of the 'director'.",
            "structure": {
              "text": "The Reader encapsulates the parsing of the common input. The Builder hierarchy makes possible the polymorphic creation of many peculiar representations or targets.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Builder-2x.png"
            },
            "example": {
              "text": "The Builder pattern separates the construction of a complex object from its representation so that the same construction process can create different representations. This pattern is used by fast food restaurants to construct children's meals. Children's meals typically consist of a main item, a side item, a drink, and a toy (e.g., a hamburger, fries, Coke, and toy dinosaur). Note that there can be variation in the content of the children's meal, but the construction process is the same. Whether a customer orders a hamburger, cheeseburger, or chicken, the process is the same. The employee at the counter directs the crew to assemble a main item, side item, and toy. These items are then placed in a bag. The drink is placed in a cup and remains outside of the bag. This same process is used at competing restaurants.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Builder_example1-2x.png"
            },
            "checkList": "Decide if a common input and many possible representations (or outputs) is the problem at hand.\nEncapsulate the parsing of the common input in a Reader class.\nDesign a standard protocol for creating all possible output representations. Capture the steps of this protocol in a Builder interface.\nDefine a Builder derived class for each target representation.\nThe client creates a Reader object and a Builder object, and registers the latter with the former.\nThe client asks the Reader to 'construct'.\nThe client asks the Builder to return the result.",
            "rulesOfThumb": "Sometimes creational patterns are complementary: Builder can use one of the other patterns to implement which components get built. Abstract Factory, Builder, and Prototype can use Singleton in their implementations.\nBuilder focuses on constructing a complex object step by step. Abstract Factory emphasizes a family of product objects (either simple or complex). Builder returns the product as a final step, but as far as the Abstract Factory is concerned, the product gets returned immediately.\nBuilder often builds a Composite.\nOften, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed."
          },
          {
            "id": 3,
            "title" :"Factory Method",
            "intent": "Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.\nDefining a 'virtual' constructor.\nThe new operator considered harmful.",
            "problem": "A framework needs to standardize the architectural model for a range of applications, but allow for individual applications to define their own domain objects and provide for their instantiation.",
            "discussion": "Factory Method is to creating objects as Template Method is to implementing an algorithm. A superclass specifies all standard and generic behavior (using pure virtual 'placeholders' for creation steps), and then delegates the creation details to subclasses that are supplied by the client.\n\nFactory Method makes a design more customizable and only a little more complicated. Other design patterns require new classes, whereas Factory Method only requires a new operation.\n\nPeople often use Factory Method as the standard way to create objects; but it isn't necessary if: the class that's instantiated never changes, or instantiation takes place in an operation that subclasses can easily override (such as an initialization operation).\n\nFactory Method is similar to Abstract Factory but without the emphasis on families.\n\nFactory Methods are routinely specified by an architectural framework, and then implemented by the user of the framework.",
            "structure": {
              "text": "The implementation of Factory Method discussed in the Gang of Four (below) largely overlaps with that of Abstract Factory. For that reason, the presentation in this chapter focuses on the approach that has become popular since.\nAn increasingly popular definition of factory method is: a static method of a class that returns an object of that class' type. But unlike a constructor, the actual object it returns might be an instance of a subclass. Unlike a constructor, an existing object might be reused, instead of a new object created. Unlike a constructor, factory methods can have different and more descriptive names (e.g. Color.make_RGB_color(float red, float green, float blue) and Color.make_HSB_color(float hue, float saturation, float brightness)\nThe client is totally decoupled from the implementation details of derived classes. Polymorphic creation is now possible.\n\n",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Factory_Method__-2x.png"
            },
            "example": {
              "text": "The Factory Method defines an interface for creating objects, but lets subclasses decide which classes to instantiate. Injection molding presses demonstrate this pattern. Manufacturers of plastic toys process plastic molding powder, and inject the plastic into molds of the desired shapes. The class of toy (car, action figure, etc.) is determined by the mold.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Factory_Method_example1-2x.png"
            },
            "checkList": "If you have an inheritance hierarchy that exercises polymorphism, consider adding a polymorphic creation capability by defining a static factory method in the base class.\nDesign the arguments to the factory method. What qualities or characteristics are necessary and sufficient to identify the correct derived class to instantiate?\nConsider designing an internal 'object pool' that will allow objects to be reused instead of created from scratch.\nConsider making all constructors private or protected.",
            "rulesOfThumb": "Abstract Factory classes are often implemented with Factory Methods, but they can be implemented using Prototype.\nFactory Methods are usually called within Template Methods.\nFactory Method: creation through inheritance. Prototype: creation through delegation.\nOften, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed.\nPrototype doesn't require subclassing, but it does require an Initialize operation. Factory Method requires subclassing, but doesn't require Initialize.\nThe advantage of a Factory Method is that it can return the same instance multiple times, or can return a subclass rather than an object of that exact type.\nSome Factory Method advocates recommend that as a matter of language design (or failing that, as a matter of style) absolutely all constructors should be private or protected. It's no one else's business whether a class manufactures a new object or recycles an old one.\nThe new operator considered harmful. There is a difference between requesting an object and creating one. The new operator always creates an object, and fails to encapsulate object creation. A Factory Method enforces that encapsulation, and allows an object to be requested without inextricable coupling to the act of creation.\n"
          },
          {
            "id": 4,
            "title" :"Prototype",
            "intent": "Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.\nCo-opt one instance of a class for use as a breeder of all future instances.\nThe new operator considered harmful.",
            "problem": "Application 'hard wires' the class of object to create in each 'new' expression.\n\n",
            "discussion": "Declare an abstract base class that specifies a pure virtual 'clone' method, and, maintains a dictionary of all 'cloneable' concrete derived classes. Any class that needs a 'polymorphic constructor' capability: derives itself from the abstract base class, registers its prototypical instance, and implements the clone() operation.\n\nThe client then, instead of writing code that invokes the \"new\" operator on a hard-wired class name, calls a 'clone' operation on the abstract base class, supplying a string or enumerated data type that designates the particular concrete derived class desired.",
            "structure": {
              "text": "The Factory knows how to find the correct Prototype, and each Product knows how to spawn new instances of itself.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Prototype-2x.png"
            },
            "example": {
              "text": "The Prototype pattern specifies the kind of objects to create using a prototypical instance. Prototypes of new products are often built prior to full production, but in this example, the prototype is passive and does not participate in copying itself. The mitotic division of a cell - resulting in two identical cells - is an example of a prototype that plays an active role in copying itself and thus, demonstrates the Prototype pattern. When a cell splits, two cells of identical genotype result. In other words, the cell clones itself.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Prototype_example1-2x.png"
            },
            "checkList": "Add a clone() method to the existing 'product' hierarchy.\nDesign a 'registry' that maintains a cache of prototypical objects. The registry could be encapsulated in a new Factory class, or in the base class of the 'product' hierarchy.\nDesign a factory method that: may (or may not) accept arguments, finds the correct prototype object, calls clone() on that object, and returns the result.\nThe client replaces all references to the new operator with calls to the factory method.",
            "rulesOfThumb": "Sometimes creational patterns are competitors: there are cases when either Prototype or Abstract Factory could be used properly. At other times they are complementary: Abstract Factory might store a set of Prototypes from which to clone and return product objects. Abstract Factory, Builder, and Prototype can use Singleton in their implementations.\nAbstract Factory classes are often implemented with Factory Methods, but they can be implemented using Prototype.\nFactory Method: creation through inheritance. Prototype: creation through delegation.\nOften, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed.\nPrototype doesn't require subclassing, but it does require an 'initialize' operation. Factory Method requires subclassing, but doesn't require Initialize.\nDesigns that make heavy use of the Composite and Decorator patterns often can benefit from Prototype as well.\nPrototype co-opts one instance of a class for use as a breeder of all future instances.\nPrototypes are useful when object initialization is expensive, and you anticipate few variations on the initialization parameters. In this context, Prototype can avoid expensive 'creation from scratch', and support cheap cloning of a pre-initialized prototype.\nPrototype is unique among the other creational patterns in that it doesn't require a class – only an object. Object-oriented languages like Self and Omega that do away with classes completely rely on prototypes for creating new objects."
          },
          {
            "id": 5,
            "title" :"Singleton",
            "intent": "Ensure a class has only one instance, and provide a global point of access to it.\nEncapsulated 'just-in-time initialization' or 'initialization on first use'.",
            "problem": "Application needs one, and only one, instance of an object. Additionally, lazy initialization and global access are necessary.",
            "discussion": "Make the class of the single instance object responsible for creation, initialization, access, and enforcement. Declare the instance as a private static data member. Provide a public static member function that encapsulates all initialization code, and provides access to the instance.\n\nThe client calls the accessor function (using the class name and scope resolution operator) whenever a reference to the single instance is required.\n\nSingleton should be considered only if all three of the following criteria are satisfied:\n\nOwnership of the single instance cannot be reasonably assigned\nLazy initialization is desirable\nGlobal access is not otherwise provided for\nIf ownership of the single instance, when and how initialization occurs, and global access are not issues, Singleton is not sufficiently interesting.\n\nThe Singleton pattern can be extended to support access to an application-specific number of instances.\n\nThe 'static member function accessor' approach will not support subclassing of the Singleton class. If subclassing is desired, refer to the discussion in the book.\n\nDeleting a Singleton class/instance is a non-trivial design problem. See 'To Kill A Singleton' by John Vlissides for a discussion.",
            "structure": {
              "text": "Make the class of the single instance responsible for access and 'initialization on first use'. The single instance is a private static attribute. The accessor function is a public static method.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/singleton1-2x.png"
            },
            "example": {
              "text": "The Singleton pattern ensures that a class has only one instance and provides a global point of access to that instance. It is named after the singleton set, which is defined to be a set containing one element. The office of the President of the United States is a Singleton. The United States Constitution specifies the means by which a president is elected, limits the term of office, and defines the order of succession. As a result, there can be at most one active president at any given time. Regardless of the personal identity of the active president, the title, 'The President of the United States' is a global point of access that identifies the person in the office.",
              "image": "https://sourcemaking.com/files/v2/content/patterns/Singleton_example1-2x.png"
            },
            "checkList": "Define a private static attribute in the 'single instance' class.\nDefine a public static accessor function in the class.\nDo 'lazy initialization' (creation on first use) in the accessor function.\nDefine all constructors to be protected or private.\nClients may only use the accessor function to manipulate the Singleton.",
            "rulesOfThumb": "Abstract Factory, Builder, and Prototype can use Singleton in their implementation.\nFacade objects are often Singletons because only one Facade object is required.\nState objects are often Singletons.\nThe advantage of Singleton over global variables is that you are absolutely sure of the number of instances when you use Singleton, and, you can change your mind and manage any number of instances.\nThe Singleton design pattern is one of the most inappropriately used patterns. Singletons are intended to be used when a class must have exactly one instance, no more, no less. Designers frequently use Singletons in a misguided attempt to replace global variables. A Singleton is, for intents and purposes, a global variable. The Singleton does not do away with the global; it merely renames it.\nWhen is Singleton unnecessary? Short answer: most of the time. Long answer: when it's simpler to pass an object resource as a reference to the objects that need it, rather than letting objects access the resource globally. The real problem with Singletons is that they give you such a good excuse not to think carefully about the appropriate visibility of an object. Finding the right balance of exposure and protection for an object is critical for maintaining flexibility.\nOur group had a bad habit of using global data, so I did a study group on Singleton. The next thing I know Singletons appeared everywhere and none of the problems related to global data went away. The answer to the global data question is not, 'Make it a Singleton.' The answer is, 'Why in the hell are you using global data?' Changing the name doesn't change the problem. In fact, it may make it worse because it gives you the opportunity to say, 'Well I'm not doing that, I'm doing this' – even though this and that are the same thing."
          }
      ]
    },
    {
      "id": 2,
      "title": "Structural Patterns",
      "icon" : "https://vnfvnglfglbgblgmlb",
      "patterns": [
        {
          "id": 1,
          "title": "Adapter",
          "intent": "Convert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.\nWrap an existing class with a new interface.\nImpedance match an old component to a new system",
          "problem": "An 'off the shelf' component offers compelling functionality that you would like to reuse, but its 'view of the world' is not compatible with the philosophy and architecture of the system currently being developed.",
          "discussion": "Reuse has always been painful and elusive. One reason has been the tribulation of designing something new, while reusing something old. There is always something not quite right between the old and the new. It may be physical dimensions or misalignment. It may be timing or synchronization. It may be unfortunate assumptions or competing standards.\n\nIt is like the problem of inserting a new three-prong electrical plug in an old two-prong wall outlet – some kind of adapter or intermediary is necessary.",
          "structure": {
            "text": "Below, a legacy Rectangle component's display() method expects to receive 'x, y, w, h' parameters. But the client wants to pass 'upper left x and y' and 'lower right x and y'. This incongruity can be reconciled by adding an additional level of indirection – i.e. an Adapter object.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Adapter_1-2x.png"
          },
          "example": {
            "text": "The Adapter pattern allows otherwise incompatible classes to work together by converting the interface of one class into an interface expected by the clients. Socket wrenches provide an example of the Adapter. A socket attaches to a ratchet, provided that the size of the drive is the same. Typical drive sizes in the United States are 1/2' and 1/4'. Obviously, a 1/2 'drive ratchet will not fit into a 1/4' drive socket unless an adapter is used. A 1/2' to 1/4' adapter has a 1/2' female connection to fit on the 1/2' drive ratchet, and a 1/4 'male connection to fit in the 1/4' drive socket.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Adapter_example1-2x.png"
          },
          "checkList": "dentify the players: the component(s) that want to be accommodated (i.e. the client), and the component that needs to adapt (i.e. the adaptee).\nIdentify the interface that the client requires.\nDesign a 'wrapper' class that can 'impedance match' the adaptee to the client.\nThe adapter/wrapper class 'has a' instance of the adaptee class.\nThe adapter/wrapper class 'maps' the client interface to the adaptee interface.\nThe client uses (is coupled to) the new interface",
          "rulesOfThumb": "Adapter makes things work after they're designed; Bridge makes them work before they are.\nBridge is designed up-front to let the abstraction and the implementation vary independently. Adapter is retrofitted to make unrelated classes work together.\nAdapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface.\nAdapter is meant to change the interface of an existing object. Decorator enhances another object without changing its interface. Decorator is thus more transparent to the application than an adapter is. As a consequence, Decorator supports recursive composition, which isn't possible with pure Adapters.\nFacade defines a new interface, whereas Adapter reuses an old interface. Remember that Adapter makes two existing interfaces work together as opposed to defining an entirely new one."
        } ,


        {
          "title": "Bridge",
          "id": 2,
          "intent": "Decouple an abstraction from its implementation so that the two can vary independently.\nPublish interface in an inheritance hierarchy, and bury implementation in its own inheritance hierarchy.\nBeyond encapsulation, to insulation",
          "problem": "'Hardening of the software arteries' has occurred by using subclassing of an abstract base class to provide alternative implementations. This locks in compile-time binding between interface and implementation. The abstraction and implementation cannot be independently extended or composed.",
          "discussion": "Decompose the component's interface and implementation into orthogonal class hierarchies. The interface class contains a pointer to the abstract implementation class. This pointer is initialized with an instance of a concrete implementation class, but all subsequent interaction from the interface class to the implementation class is limited to the abstraction maintained in the implementation base class. The client interacts with the interface class, and it in turn 'delegates' all requests to the implementation class.\n\nThe interface object is the 'handle' known and used by the client; while the implementation object, or 'body', is safely encapsulated to ensure that it may continue to evolve, or be entirely replaced (or shared at run-time.\n\nUse the Bridge pattern when:\n\nyou want run-time binding of the implementation,\nyou have a proliferation of classes resulting from a coupled interface and numerous implementations,\nyou want to share an implementation among multiple objects,\nyou need to map orthogonal class hierarchies.\nConsequences include:\n\ndecoupling the object's interface,\nimproved extensibility (you can extend (i.e. subclass) the abstraction and implementation hierarchies independently),\nhiding details from clients.\nBridge is a synonym for the 'handle/body' idiom. This is a design mechanism that encapsulates an implementation class inside of an interface class. The former is the body, and the latter is the handle. The handle is viewed by the user as the actual class, but the work is done in the body. 'The handle/body class idiom may be used to decompose a complex abstraction into smaller, more manageable classes. The idiom may reflect the sharing of a single resource by multiple classes that control access to it (e.g. reference counting).'",
          "structure": {
            "text": "The Client doesn't want to deal with platform-dependent details. The Bridge pattern encapsulates this complexity behind an abstraction 'wrapper'.\n\nBridge emphasizes identifying and decoupling 'interface' abstraction from 'implementation' abstraction.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Bridge___-2x.png"
          },
          "example": {
            "text": "The Bridge pattern decouples an abstraction from its implementation, so that the two can vary independently. A household switch controlling lights, ceiling fans, etc. is an example of the Bridge. The purpose of the switch is to turn a device on or off. The actual switch can be implemented as a pull chain, simple two position switch, or a variety of dimmer switches.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Bridge_example-2x.png"
          },
          "checkList": "Decide if two orthogonal dimensions exist in the domain. These independent concepts could be: abstraction/platform, or domain/infrastructure, or front-end/back-end, or interface/implementation.\nDesign the separation of concerns: what does the client want, and what do the platforms provide.\nDesign a platform-oriented interface that is minimal, necessary, and sufficient. Its goal is to decouple the abstraction from the platform.\nDefine a derived class of that interface for each platform.\nCreate the abstraction base class that 'has a' platform object and delegates the platform-oriented functionality to it.\nDefine specializations of the abstraction class if desired.\n",
          "rulesOfThumb": "Adapter makes things work after they're designed; Bridge makes them work before they are.\nBridge is designed up-front to let the abstraction and the implementation vary independently. Adapter is retrofitted to make unrelated classes work together.\nState, Strategy, Bridge (and to some degree Adapter) have similar solution structures. They all share elements of the 'handle/body' idiom. They differ in intent - that is, they solve different problems.\nThe structure of State and Bridge are identical (except that Bridge admits hierarchies of envelope classes, whereas State allows only one). The two patterns use the same structure to solve different problems: State allows an object's behavior to change along with its state, while Bridge's intent is to decouple an abstraction from its implementation so that the two can vary independently.\nIf interface classes delegate the creation of their implementation classes (instead of creating/coupling themselves directly), then the design usually uses the Abstract Factory pattern to create the implementation objects."
        },
        {
          "title": "Composite",
          "id": 3,
          "intent": "Compose objects into tree structures to represent whole-part hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\nRecursive composition\n'Directories contain entries, each of which could be a directory.'\n1-to-many 'has a' up the 'is a' hierarchy",
          "problem": "Application needs to manipulate a hierarchical collection of 'primitive' and 'composite' objects. Processing of a primitive object is handled one way, and processing of a composite object is handled differently. Having to query the 'type' of each object before attempting to process it is not desirable.",
          "discussion": "Define an abstract base class (Component) that specifies the behavior that needs to be exercised uniformly across all primitive and composite objects. Subclass the Primitive and Composite classes off of the Component class. Each Composite object 'couples' itself only to the abstract type Component as it manages its 'children'.\n\nUse this pattern whenever you have 'composites that contain components, each of which could be a composite'.\n\nChild management methods [e.g. addChild(), removeChild()] should normally be defined in the Composite class. Unfortunately, the desire to treat Primitives and Composites uniformly requires that these methods be moved to the abstract Component class. See the 'Opinions' section below for a discussion of 'safety' versus 'transparency' issues.",
          "structure": {
            "text": "Composites that contain Components, each of which could be a Composite.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Composite-2x.png"
          },
          "example": {
            "text": "The Composite composes objects into tree structures and lets clients treat individual objects and compositions uniformly. Although the example is abstract, arithmetic expressions are Composites. An arithmetic expression consists of an operand, an operator (+ - * /), and another operand. The operand can be a number, or another arithmetic expression. Thus, 2 + 3 and (2 + 3) + (4 * 6) are both valid expressions.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Composite_example1-2x.png"
          },
          "checkList": "Ensure that your problem is about representing 'whole-part' hierarchical relationships.\nConsider the heuristic, 'Containers that contain containees, each of which could be a container.' For example, 'Assemblies that contain components, each of which could be an assembly.' Divide your domain concepts into container classes, and containee classes.\nCreate a 'lowest common denominator' interface that makes your containers and containees interchangeable. It should specify the behavior that needs to be exercised uniformly across all containee and container objects.\nAll container and containee classes declare an 'is a' relationship to the interface.\nAll container classes declare a one-to-many 'has a' relationship to the interface.\nContainer classes leverage polymorphism to delegate to their containee objects.\nChild management methods [e.g. addChild(), removeChild()] should normally be defined in the Composite class. Unfortunately, the desire to treat Leaf and Composite objects uniformly may require that these methods be promoted to the abstract Component class. See the Gang of Four for a discussion of these 'safety' versus 'transparency' trade-offs.\n",
          "rulesOfThumb": "Composite and Decorator have similar structure diagrams, reflecting the fact that both rely on recursive composition to organize an open-ended number of objects.\nComposite can be traversed with Iterator. Visitor can apply an operation over a Composite. Composite could use Chain of Responsibility to let components access global properties through their parent. It could also use Decorator to override these properties on parts of the composition. It could use Observer to tie one object structure to another and State to let a component change its behavior as its state changes.\nComposite can let you compose a Mediator out of smaller pieces through recursive composition.\nDecorator is designed to let you add responsibilities to objects without subclassing. Composite's focus is not on embellishment but on representation. These intents are distinct but complementary. Consequently, Composite and Decorator are often used in concert.\nFlyweight is often combined with Composite to implement shared leaf nodes."
        },
        {
          "title": "Decorator",
          "id": 4,
          "intent": "Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.\nClient-specified embellishment of a core object by recursively wrapping it.\nWrapping a gift, putting it in a box, and wrapping the box.\n",
          "problem": "You want to add behavior or state to individual objects at run-time. Inheritance is not feasible because it is static and applies to an entire class.",
          "discussion": "Suppose you are working on a user interface toolkit and you wish to support adding borders and scroll bars to windows. You could define an inheritance hierarchy like ...",
          "structure": {
            "text": "The client is always interested in CoreFunctionality.doThis(). The client may, or may not, be interested in OptionalOne.doThis() and OptionalTwo.doThis(). Each of these classes always delegate to the Decorator base class, and that class always delegates to the contained 'wrappee' object.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Decorator__1-2x.png"
          },
          "example": {
            "text": "The Decorator attaches additional responsibilities to an object dynamically. The ornaments that are added to pine or fir trees are examples of Decorators. Lights, garland, candy canes, glass ornaments, etc., can be added to a tree to give it a festive look. The ornaments do not change the tree itself which is recognizable as a Christmas tree regardless of particular ornaments used. As an example of additional functionality, the addition of lights allows one to 'light up' a Christmas tree.\n\nAnother example: assault gun is a deadly weapon on it's own. But you can apply certain 'decorations' to make it more accurate, silent and devastating.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Decorator_example-2x.png"
          },
          "checkList": "Ensure the context is: a single core (or non-optional) component, several optional embellishments or wrappers, and an interface that is common to all.\nCreate a 'Lowest Common Denominator' interface that makes all classes interchangeable.\nCreate a second level base class (Decorator) to support the optional wrapper classes.\nThe Core class and Decorator class inherit from the LCD interface.\nThe Decorator class declares a composition relationship to the LCD interface, and this data member is initialized in its constructor.\nThe Decorator class delegates to the LCD object.\nDefine a Decorator derived class for each optional embellishment.\nDecorator derived classes implement their wrapper functionality - and - delegate to the Decorator base class.\nThe client configures the type and ordering of Core and Decorator objects.",
          "rulesOfThumb": "Adapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface.\nAdapter changes an object's interface, Decorator enhances an object's responsibilities. Decorator is thus more transparent to the client. As a consequence, Decorator supports recursive composition, which isn't possible with pure Adapters.\nComposite and Decorator have similar structure diagrams, reflecting the fact that both rely on recursive composition to organize an open-ended number of objects.\nA Decorator can be viewed as a degenerate Composite with only one component. However, a Decorator adds additional responsibilities - it isn't intended for object aggregation.\nDecorator is designed to let you add responsibilities to objects without subclassing. Composite's focus is not on embellishment but on representation. These intents are distinct but complementary. Consequently, Composite and Decorator are often used in concert.\nComposite could use Chain of Responsibility to let components access global properties through their parent. It could also use Decorator to override these properties on parts of the composition.\nDecorator and Proxy have different purposes but similar structures. Both describe how to provide a level of indirection to another object, and the implementations keep a reference to the object to which they forward requests.\nDecorator lets you change the skin of an object. Strategy lets you change the guts."
        },
        {
          "title": "Facade",
          "id": 5,
          "intent": "Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\nWrap a complicated subsystem with a simpler interface.\n",
          "problem": "A segment of the client community needs a simplified interface to the overall functionality of a complex subsystem.",
          "discussion": "Facade discusses encapsulating a complex subsystem within a single interface object. This reduces the learning curve necessary to successfully leverage the subsystem. It also promotes decoupling the subsystem from its potentially many clients. On the other hand, if the Facade is the only access point for the subsystem, it will limit the features and flexibility that 'power users' may need.\n\nThe Facade object should be a fairly simple advocate or facilitator. It should not become an all-knowing oracle or 'god' object.",
          "structure": {
            "text": "Facade takes a 'riddle wrapped in an enigma shrouded in mystery', and interjects a wrapper that tames the amorphous and inscrutable mass of software.\n\n",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Facade1-2x.png"
          },
          "example": {
            "text": "The Facade defines a unified, higher level interface to a subsystem that makes it easier to use. Consumers encounter a Facade when ordering from a catalog. The consumer calls one number and speaks with a customer service representative. The customer service representative acts as a Facade, providing an interface to the order fulfillment department, the billing department, and the shipping department.\n\n",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Facade_example1-2x.png"
          },
          "checkList": "Identify a simpler, unified interface for the subsystem or component.\nDesign a 'wrapper' class that encapsulates the subsystem.\nThe facade/wrapper captures the complexity and collaborations of the component, and delegates to the appropriate methods.\nThe client uses (is coupled to) the Facade only.\nConsider whether additional Facades would add value.\n",
          "rulesOfThumb": "Facade defines a new interface, whereas Adapter uses an old interface. Remember that Adapter makes two existing interfaces work together as opposed to defining an entirely new one.\nWhereas Flyweight shows how to make lots of little objects, Facade shows how to make a single object represent an entire subsystem.\nMediator is similar to Facade in that it abstracts functionality of existing classes. Mediator abstracts/centralizes arbitrary communications between colleague objects. It routinely 'adds value', and it is known/referenced by the colleague objects. In contrast, Facade defines a simpler interface to a subsystem, it doesn't add new functionality, and it is not known by the subsystem classes.\nAbstract Factory can be used as an alternative to Facade to hide platform-specific classes.\nFacade objects are often Singletons because only one Facade object is required.\nAdapter and Facade are both wrappers; but they are different kinds of wrappers. The intent of Facade is to produce a simpler interface, and the intent of Adapter is to design to an existing interface. While Facade routinely wraps multiple objects and Adapter wraps a single object; Facade could front-end a single complex object and Adapter could wrap several legacy objects.\n"
        },
        {
          "title": "Flyweight",
          "id": 6,
          "intent": "Use sharing to support large numbers of fine-grained objects efficiently.\nThe Motif GUI strategy of replacing heavy-weight widgets with light-weight gadgets.",
          "problem": "Designing objects down to the lowest levels of system 'granularity' provides optimal flexibility, but can be unacceptably expensive in terms of performance and memory usage.",
          "discussion": "The Flyweight pattern describes how to share objects to allow their use at fine granularity without prohibitive cost. Each 'flyweight' object is divided into two pieces: the state-dependent (extrinsic) part, and the state-independent (intrinsic) part. Intrinsic state is stored (shared) in the Flyweight object. Extrinsic state is stored or computed by client objects, and passed to the Flyweight when its operations are invoked.\n\nAn illustration of this approach would be Motif widgets that have been re-engineered as light-weight gadgets. Whereas widgets are 'intelligent' enough to stand on their own; gadgets exist in a dependent relationship with their parent layout manager widget. Each layout manager provides context-dependent event handling, real estate management, and resource services to its flyweight gadgets, and each gadget is only responsible for context-independent state and behavior.",
          "structure": {
            "text": "Flyweights are stored in a Factory's repository. The client restrains herself from creating Flyweights directly, and requests them from the Factory. Each Flyweight cannot stand on its own. Any attributes that would make sharing impossible must be supplied by the client whenever a request is made of the Flyweight. If the context lends itself to 'economy of scale' (i.e. the client can easily compute or look-up the necessary attributes), then the Flyweight pattern offers appropriate leverage.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Flyweight1-2x.png"
          },
          "example": {
            "text": "The Flyweight uses sharing to support large numbers of objects efficiently. Modern web browsers use this technique to prevent loading same images twice. When browser loads a web page, it traverse through all images on that page. Browser loads all new images from Internet and places them the internal cache. For already loaded images, a flyweight object is created, which has some unique data like position within the page, but everything else is referenced to the cached one.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Flyweight_example1-2x.png"
          },
          "checkList": "Ensure that object overhead is an issue needing attention, and, the client of the class is able and willing to absorb responsibility realignment.\nDivide the target class's state into: shareable (intrinsic) state, and non-shareable (extrinsic) state.\nRemove the non-shareable state from the class attributes, and add it the calling argument list of affected methods.\nCreate a Factory that can cache and reuse existing class instances.\nThe client must use the Factory instead of the new operator to request objects.\nThe client (or a third party) must look-up or compute the non-shareable state, and supply that state to class methods.",
          "rulesOfThumb": "Whereas Flyweight shows how to make lots of little objects, Facade shows how to make a single object represent an entire subsystem.\nFlyweight is often combined with Composite to implement shared leaf nodes.\nTerminal symbols within Interpreter's abstract syntax tree can be shared with Flyweight.\nFlyweight explains when and how State objects can be shared.\n\n"
        },
        {
          "title": "Proxy",
          "id": 7,
          "intent": "Provide a surrogate or placeholder for another object to control access to it.\nUse an extra level of indirection to support distributed, controlled, or intelligent access.\nAdd a wrapper and delegation to protect the real component from undue complexity.\n",
          "problem": "You need to support resource-hungry objects, and you do not want to instantiate such objects unless and until they are actually requested by the client.",
          "discussion": "Design a surrogate, or proxy, object that: instantiates the real object the first time the client makes a request of the proxy, remembers the identity of this real object, and forwards the instigating request to this real object. Then all subsequent requests are simply forwarded directly to the encapsulated real object.\n\nThere are four common situations in which the Proxy pattern is applicable.\n\nA virtual proxy is a placeholder for 'expensive to create' objects. The real object is only created when a client first requests/accesses the object.\nA remote proxy provides a local representative for an object that resides in a different address space. This is what the 'stub' code in RPC and CORBA provides.\nA protective proxy controls access to a sensitive master object. The 'surrogate' object checks that the caller has the access permissions required prior to forwarding the request.\nA smart proxy interposes additional actions when an object is accessed. Typical uses include:\nCounting the number of references to the real object so that it can be freed automatically when there are no more references (aka smart pointer),\nLoading a persistent object into memory when it's first referenced,\nChecking that the real object is locked before it is accessed to ensure that no other object can change it.",
          "structure": {
            "text": "By defining a Subject interface, the presence of the Proxy object standing in place of the RealSubject is transparent to the client.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Proxy1-2x.png"
          },
          "example": {
            "text": "The Proxy provides a surrogate or place holder to provide access to an object. A check or bank draft is a proxy for funds in an account. A check can be used in place of cash for making purchases and ultimately controls access to cash in the issuer's account.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Proxy_example1-2x.png"
          },
          "checkList": "Identify the leverage or 'aspect' that is best implemented as a wrapper or surrogate.\nDefine an interface that will make the proxy and the original component interchangeable.\nConsider defining a Factory that can encapsulate the decision of whether a proxy or original object is desirable.\nThe wrapper class holds a pointer to the real class and implements the interface.\nThe pointer may be initialized at construction, or on first use.\nEach wrapper method contributes its leverage, and delegates to the wrappee object.",
          "rulesOfThumb": "Adapter provides a different interface to its subject. Proxy provides the same interface. Decorator provides an enhanced interface.\nDecorator and Proxy have different purposes but similar structures. Both describe how to provide a level of indirection to another object, and the implementations keep a reference to the object to which they forward requests."
        }
      ]
    },
    {
      "id": 3,
      "title": "Behavioral Patterns",
      "icon" : "https://.......",
      "patterns": [
        {
          "id": 1,
          "title" :"Chain of Responsibility",
          "intent": "Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.\nLaunch-and-leave requests with a single processing pipeline that contains many possible handlers.\nAn object-oriented linked list with recursive traversal.",
          "problem": "There is a potentially variable number of 'handler' or 'processing element' or 'node' objects, and a stream of requests that must be handled. Need to efficiently process the requests without hard-wiring handler relationships and precedence, or request-to-handler mappings.",
          "discussion": "Encapsulate the processing elements inside a 'pipeline' abstraction; and have clients 'launch and leave' their requests at the entrance to the pipeline. The pattern chains the receiving objects together, and then passes any request messages from object to object until it reaches an object capable of handling the message. The number and type of handler objects isn't known a priori, they can be configured dynamically. The chaining mechanism uses recursive composition to allow an unlimited number of handlers to be linked.\n\nChain of Responsibility simplifies object interconnections. Instead of senders and receivers maintaining references to all candidate receivers, each sender keeps a single reference to the head of the chain, and each receiver keeps a single reference to its immediate successor in the chain.\n\nMake sure there exists a 'safety net' to 'catch' any requests which go unhandled.\n\nDo not use Chain of Responsibility when each request is only handled by one handler, or, when the client object knows which service object should handle the request.",
          "structure": {
            "text": "The derived classes know how to satisfy Client requests. If the 'current' object is not available or sufficient, then it delegates to the base class, which delegates to the 'next' object, and the circle of life continues. Multiple handlers could contribute to the handling of each request. The request can be passed down the entire length of the chain, with the last link being careful not to delegate to a 'null next'.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Chain_of_responsibility__-2x.png"
          },
          "example": {
            "text": "The Chain of Responsibility pattern avoids coupling the sender of a request to the receiver by giving more than one object a chance to handle the request. ATM use the Chain of Responsibility in money giving mechanism.",
            "image": "https://sourcemaking.com/files/sm/images/patterns/Chain_of_responsibility_example.png"
          },
          "checkList": "The base class maintains a 'next' pointer. Each derived class implements its contribution for handling the request.\nIf the request needs to be 'passed on', then the derived class 'calls back' to the base class, which delegates to the 'next' pointer.\nThe client (or some third party) creates and links the chain (which may include a link from the last node to the root node).\nThe client 'launches and leaves', each request with the root of the chain.\nRecursive delegation produces the illusion of magic.",
          "rulesOfThumb": "Chain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers.\nChain of Responsibility can use Command to represent requests as objects.\nChain of Responsibility is often applied in conjunction with Composite. There, a component's parent can act as its successor."
        },
        {
          "id": 2,
          "title" :"Command",
          "intent": "Encapsulate a request as an object, thereby letting you parametrize clients with different requests, queue or log requests, and support undoable operations.\nPromote 'invocation of a method on an object' to full object status\nAn object-oriented callback",
          "problem": "Need to issue requests to objects without knowing anything about the operation being requested or the receiver of the request.",
          "discussion": "Command decouples the object that invokes the operation from the one that knows how to perform it. To achieve this separation, the designer creates an abstract base class that maps a receiver (an object) with an action (a pointer to a member function). The base class contains an execute() method that simply calls the action on the receiver.\n\nAll clients of Command objects treat each object as a 'black box' by simply invoking the object's virtual execute() method whenever the client requires the object's 'service'.\n\nA Command class holds some subset of the following: an object, a method to be applied to the object, and the arguments to be passed when the method is applied. The Command's 'execute' method then causes the pieces to come together.\n\nSequences of Command objects can be assembled into composite (or macro) commands.",
          "structure": {
            "text": "The client that creates a command is not the same client that executes it. This separation provides flexibility in the timing and sequencing of commands. Materializing commands as objects means they can be passed, staged, shared, loaded in a table, and otherwise instrumented or manipulated like any other object.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Command-2x.png"
          },
          "example": {
            "text": "The Command pattern allows requests to be encapsulated as objects, thereby allowing clients to be parametrized with different requests. The 'check' at a diner is an example of a Command pattern. The waiter or waitress takes an order or command from a customer and encapsulates that order by writing it on the check. The order is then queued for a short order cook. Note that the pad of 'checks' used by each waiter is not dependent on the menu, and therefore they can support commands to cook many different items.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Command_example1-2x.png"
          },
          "checkList": "Define a Command interface with a method signature like execute().\nCreate one or more derived classes that encapsulate some subset of the following: a 'receiver' object, the method to invoke, the arguments to pass.\nInstantiate a Command object for each deferred execution request.\nPass the Command object from the creator (aka sender) to the invoker (aka receiver).\nThe invoker decides when to execute().",
          "rulesOfThumb": "Chain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different trade-offs. Command normally specifies a sender-receiver connection with a subclass.\nChain of Responsibility can use Command to represent requests as objects.\nCommand and Memento act as magic tokens to be passed around and invoked at a later time. In Command, the token represents a request; in Memento, it represents the internal state of an object at a particular time. Polymorphism is important to Command, but not to Memento because its interface is so narrow that a memento can only be passed as a value.\nCommand can use Memento to maintain the state required for an undo operation.\nMacroCommands can be implemented with Composite.\nA Command that must be copied before being placed on a history list acts as a Prototype.\nTwo important aspects of the Command pattern: interface separation (the invoker is isolated from the receiver), time separation (stores a ready-to-go processing request that's to be stated later)."
        },
        {
          "id": 3,
          "title" :"Interpreter",
          "intent": "Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.\nMap a domain to a language, the language to a grammar, and the grammar to a hierarchical object-oriented design.",
          "problem": "A class of problems occurs repeatedly in a well-defined and well-understood domain. If the domain were characterized with a 'language', then problems could be easily solved with an interpretation 'engine'.",
          "discussion": "The Interpreter pattern discusses: defining a domain language (i.e. problem characterization) as a simple language grammar, representing domain rules as language sentences, and interpreting these sentences to solve the problem. The pattern uses a class to represent each grammar rule. And since grammars are usually hierarchical in structure, an inheritance hierarchy of rule classes maps nicely.\n\nAn abstract base class specifies the method interpret(). Each concrete subclass implements interpret() by accepting (as an argument) the current state of the language stream, and adding its contribution to the problem solving process.",
          "structure": {
            "text": "Interpreter suggests modeling the domain with a recursive grammar. Each rule in the grammar is either a 'composite' (a rule that references other rules) or a terminal (a leaf node in a tree structure). Interpreter relies on the recursive traversal of the Composite pattern to interpret the 'sentences' it is asked to process.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Interpreter1-2x.png"
          },
          "example": {
            "text": "The Interpreter pattern defines a grammatical representation for a language and an interpreter to interpret the grammar. Musicians are examples of Interpreters. The pitch of a sound and its duration can be represented in musical notation on a staff. This notation provides the language of music. Musicians playing the music from the score are able to reproduce the original pitch and duration of each sound represented.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Interpreter_example1-2x.png"
          },
          "checkList": "Decide if a 'little language' offers a justifiable return on investment.\nDefine a grammar for the language.\nMap each production in the grammar to a class.\nOrganize the suite of classes into the structure of the Composite pattern.\nDefine an interpret(Context) method in the Composite hierarchy.\nThe Context object encapsulates the current state of the input and output as the former is parsed and the latter is accumulated. It is manipulated by each grammar class as the 'interpreting' process transforms the input into the output.",
          "rulesOfThumb": "Considered in its most general form (i.e. an operation distributed over a class hierarchy based on the Composite pattern), nearly every use of the Composite pattern will also contain the Interpreter pattern. But the Interpreter pattern should be reserved for those cases in which you want to think of this class hierarchy as defining a language.\nInterpreter can use State to define parsing contexts.\nThe abstract syntax tree of Interpreter is a Composite (therefore Iterator and Visitor are also applicable).\nTerminal symbols within Interpreter's abstract syntax tree can be shared with Flyweight.\nThe pattern doesn't address parsing. When the grammar is very complex, other techniques (such as a parser) are more appropriate."
        },
        {
          "id": 4,
          "title" :"Iterator",
          "intent": "Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.\nThe C++ and Java standard library abstraction that makes it possible to decouple collection classes and algorithms.\nPromote to 'full object status', the traversal of a collection.\nPolymorphic traversal",
          "problem": "Need to 'abstract' the traversal of wildly different data structures so that algorithms can be defined that are capable of interfacing with each transparently.",
          "discussion": "'An aggregate object such as a list should give you a way to access its elements without exposing its internal structure. Moreover, you might want to traverse the list in different ways, depending on what you need to accomplish. But you probably don't want to bloat the List interface with operations for different traversals, even if you could anticipate the ones you'll require. You might also need to have more than one traversal pending on the same list.' And, providing a uniform interface for traversing many types of aggregate objects (i.e. polymorphic iteration) might be valuable.\n\nThe Iterator pattern lets you do all this. The key idea is to take the responsibility for access and traversal out of the aggregate object and put it into an Iterator object that defines a standard traversal protocol.\n\nThe Iterator abstraction is fundamental to an emerging technology called 'generic programming'. This strategy seeks to explicitly separate the notion of 'algorithm' from that of 'data structure'. The motivation is to: promote component-based development, boost productivity, and reduce configuration management.\n\nAs an example, if you wanted to support four data structures (array, binary tree, linked list, and hash table) and three algorithms (sort, find, and merge), a traditional approach would require four times three permutations to develop and maintain. Whereas, a generic programming approach would only require four plus three configuration items.",
          "structure": {
            "text": "The Client uses the Collection class' public interface directly. But access to the Collection's elements is encapsulated behind the additional level of abstraction called Iterator. Each Collection derived class knows which Iterator derived class to create and return. After that, the Client relies on the interface defined in the Iterator base class.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Iterator-2x.png"
          },
          "example": {
            "text": "The Iterator provides ways to access elements of an aggregate object sequentially without exposing the underlying structure of the object. Files are aggregate objects. In office settings where access to files is made through administrative or secretarial staff, the Iterator pattern is demonstrated with the secretary acting as the Iterator. Several television comedy skits have been developed around the premise of an executive trying to understand the secretary's filing system. To the executive, the filing system is confusing and illogical, but the secretary is able to access files quickly and efficiently.\n\nOn early television sets, a dial was used to change channels. When channel surfing, the viewer was required to move the dial through each channel position, regardless of whether or not that channel had reception. On modern television sets, a next and previous button are used. When the viewer selects the \"next\" button, the next tuned channel will be displayed. Consider watching television in a hotel room in a strange city. When surfing through channels, the channel number is not important, but the programming is. If the programming on one channel is not of interest, the viewer can request the next channel, without knowing its number.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Iterator_example1-2x.png"
          },
          "checkList": "Add a create_iterator() method to the 'collection' class, and grant the 'iterator' class privileged access.\nDesign an 'iterator' class that can encapsulate traversal of the 'collection' class.\nClients ask the collection object to create an iterator object.\nClients use the first(), is_done(), next(), and current_item() protocol to access the elements of the collection class.",
          "rulesOfThumb": "The abstract syntax tree of Interpreter is a Composite (therefore Iterator and Visitor are also applicable).\nIterator can traverse a Composite. Visitor can apply an operation over a Composite.\nPolymorphic Iterators rely on Factory Methods to instantiate the appropriate Iterator subclass.\nMemento is often used in conjunction with Iterator. An Iterator can use a Memento to capture the state of an iteration. The Iterator stores the Memento internally."
        },
        {
          "id": 5,
          "title" :"Mediator",
          "intent": "Define an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.\nDesign an intermediary to decouple many peers.\nPromote the many-to-many relationships between interacting peers to 'full object status'.",
          "problem": "We want to design reusable components, but dependencies between the potentially reusable pieces demonstrates the 'spaghetti code' phenomenon (trying to scoop a single serving results in an 'all or nothing clump').",
          "discussion": "In Unix, permission to access system resources is managed at three levels of granularity: world, group, and owner. A group is a collection of users intended to model some functional affiliation. Each user on the system can be a member of one or more groups, and each group can have zero or more users assigned to it. Next figure shows three users that are assigned to all three groups.If we were to model this in software, we could decide to have User objects coupled to Group objects, and Group objects coupled to User objects. Then when changes occur, both classes and all their instances would be affected.\n\nAn alternate approach would be to introduce 'an additional level of indirection' - take the mapping of users to groups and groups to users, and make it an abstraction unto itself. This offers several advantages: Users and Groups are decoupled from one another, many mappings can easily be maintained and manipulated simultaneously, and the mapping abstraction can be extended in the future by defining derived classes. Partitioning a system into many objects generally enhances reusability, but proliferating interconnections between those objects tend to reduce it again. The mediator object: encapsulates all interconnections, acts as the hub of communication, is responsible for controlling and coordinating the interactions of its clients, and promotes loose coupling by keeping objects from referring to each other explicitly.\n\nThe Mediator pattern promotes a 'many-to-many relationship network' to 'full object status'. Modelling the inter-relationships with an object enhances encapsulation, and allows the behavior of those inter-relationships to be modified or extended through subclassing.\n\nAn example where Mediator is useful is the design of a user and group capability in an operating system. A group can have zero or more users, and, a user can be a member of zero or more groups. The Mediator pattern provides a flexible and non-invasive way to associate and manage users and groups.",
          "structure": {
            "text": "Colleagues (or peers) are not coupled to one another. Each talks to the Mediator, which in turn knows and conducts the orchestration of the others. The 'many to many' mapping between colleagues that would otherwise exist, has been 'promoted to full object status'. This new abstraction provides a locus of indirection where additional leverage can be hosted.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Mediator___1-2x.png"
          },
          "example": {
            "text": "The Mediator defines an object that controls how a set of objects interact. Loose coupling between colleague objects is achieved by having colleagues communicate with the Mediator, rather than with each other. The control tower at a controlled airport demonstrates this pattern very well. The pilots of the planes approaching or departing the terminal area communicate with the tower rather than explicitly communicating with one another. The constraints on who can take off or land are enforced by the tower. It is important to note that the tower does not control the whole flight. It exists only to enforce constraints in the terminal area.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Mediator_example-2x.png"
          },
          "checkList": "Identify a collection of interacting objects that would benefit from mutual decoupling.\nEncapsulate those interactions in the abstraction of a new class.\nCreate an instance of that new class and rework all 'peer' objects to interact with the Mediator only.\nBalance the principle of decoupling with the principle of distributing responsibility evenly.\nBe careful not to create a 'controller' or 'god' object.",
          "rulesOfThumb": "Chain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers. Command normally specifies a sender-receiver connection with a subclass. Mediator has senders and receivers reference each other indirectly. Observer defines a very decoupled interface that allows for multiple receivers to be configured at run-time.\nMediator and Observer are competing patterns. The difference between them is that Observer distributes communication by introducing 'observer' and 'subject' objects, whereas a Mediator object encapsulates the communication between other objects. We've found it easier to make reusable Observers and Subjects than to make reusable Mediators.\nOn the other hand, Mediator can leverage Observer for dynamically registering colleagues and communicating with them.\nMediator is similar to Facade in that it abstracts functionality of existing classes. Mediator abstracts/centralizes arbitrary communication between colleague objects, it routinely 'adds value', and it is known/referenced by the colleague objects (i.e. it defines a multidirectional protocol). In contrast, Facade defines a simpler interface to a subsystem, it doesn't add new functionality, and it is not known by the subsystem classes (i.e. it defines a unidirectional protocol where it makes requests of the subsystem classes but not vice versa)."
        },
        {
          "id": 6,
          "title" :"Memento",
          "intent": "Without violating encapsulation, capture and externalize an object's internal state so that the object can be returned to this state later.\nA magic cookie that encapsulates a 'check point' capability.\nPromote undo or rollback to full object status.",
          "problem": "Need to restore an object back to its previous state (e.g. 'undo' or 'rollback' operations).",
          "discussion": "The client requests a Memento from the source object when it needs to checkpoint the source object's state. The source object initializes the Memento with a characterization of its state. The client is the 'care-taker' of the Memento, but only the source object can store and retrieve information from the Memento (the Memento is 'opaque' to the client and all other objects). If the client subsequently needs to 'rollback' the source object's state, it hands the Memento back to the source object for reinstatement.\n\nAn unlimited 'undo' and 'redo' capability can be readily implemented with a stack of Command objects and a stack of Memento objects.\n\nThe Memento design pattern defines three distinct roles:\n\nOriginator - the object that knows how to save itself.\nCaretaker - the object that knows why and when the Originator needs to save and restore itself.\nMemento - the lock box that is written and read by the Originator, and shepherded by the Caretaker.",
          "structure": {
            "text": " ",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Memento-2x.png"
          },
          "example": {
            "text": "The Memento captures and externalizes an object's internal state so that the object can later be restored to that state. This pattern is common among do-it-yourself mechanics repairing drum brakes on their cars. The drums are removed from both sides, exposing both the right and left brakes. Only one side is disassembled and the other serves as a Memento of how the brake parts fit together. Only after the job has been completed on one side is the other side disassembled. When the second side is disassembled, the first side acts as the Memento.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Memento_example-2x.png"
          },
          "checkList": "Identify the roles of “caretaker” and “originator”.\nCreate a Memento class and declare the originator a friend.\nCaretaker knows when to 'check point' the originator.\nOriginator creates a Memento and copies its state to that Memento.\nCaretaker holds on to (but cannot peek into) the Memento.\nCaretaker knows when to 'roll back' the originator.\nOriginator reinstates itself using the saved state in the Memento.",
          "rulesOfThumb": "Command and Memento act as magic tokens to be passed around and invoked at a later time. In Command, the token represents a request; in Memento, it represents the internal state of an object at a particular time. Polymorphism is important to Command, but not to Memento because its interface is so narrow that a memento can only be passed as a value.\nCommand can use Memento to maintain the state required for an undo operation.\nMemento is often used in conjunction with Iterator. An Iterator can use a Memento to capture the state of an iteration. The Iterator stores the Memento internally."
        },
        {
          "id": 7,
          "title" :"Null Object",
          "intent": "The intent of a Null Object is to encapsulate the absence of an object by providing a substitutable alternative that offers suitable default do nothing behavior. In short, a design where 'nothing will come of nothing' \n\nUse the Null Object pattern when\n\nan object requires a collaborator. The Null Object pattern does not introduce this collaboration--it makes use of a collaboration that already exists\nsome collaborator instances should do nothing\nyou want to abstract the handling of null away from the client\n",
          "problem": "Given that an object reference may be optionally null, and that the result of a null check is to do nothing or use some default value, how can the absence of an object — the presence of a null reference — be treated transparently?\n\n",
          "discussion": "Sometimes a class that requires a collaborator does not need the collaborator to do anything. However, the class wishes to treat a collaborator that does nothing the same way it treats one that actually provides behavior.\n\nConsider for example a simple screen saver which displays balls that move about the screen and have special color effects. This is easily achieved by creating a Ball class to represent the balls and using a Strategy pattern to control the ball's motion and another Strategy pattern to control the ball's color.\n\nIt would then be trivial to write strategies for many different types of motion and color effects and create balls with any combination of those. However, to start with you want to create the simplest strategies possible to make sure everything is working. And these strategies could also be useful later since you want as strategies as possible strategies.\n\n  Now, the simplest strategy would be no strategy. That is do nothing, don't move and don't change color. However, the Strategy pattern requires the ball to have objects which implement the strategy interfaces. This is where the Null Object pattern becomes useful.\n\nSimply implement a NullMovementStrategy which doesn't move the ball and a NullColorStrategy which doesn't change the ball's color. Both of these can probably be implemented with essentially no code. All the methods in these classes do 'nothing'. They are perfect examples of the Null Object Pattern.\n\nThe key to the Null Object pattern is an abstract class that defines the interface for all objects of this type. The Null Object is implemented as a subclass of this abstract class. Because it conforms to the abstract class' interface, it can be used any place this type of object is needed. As compared to using a special 'null' value which doesn't actually implement the abstract interface and which must constantly be checked for with special code in any object which uses the abstract interface.\n\nIt is sometimes thought that Null Objects are over simple and 'stupid' but in truth a Null Object always knows exactly what needs to be done without interacting with any other objects. So in truth it is very 'smart.'\n\n",
          "structure": {
            "text": "Client -\nrequires a collaborator.\nAbstractObject -\ndeclares the interface for Client's collaborator\nimplements default behavior for the interface common to all classes, as appropriate\nRealObject -\ndefines a concrete subclass of AbstractObject whose instances provide useful behavior that Client expects\nNullObject -\nprovides an interface identical to AbstractObject's so that a null object can be substituted for a real object\nimplements its interface to do nothing. What exactly it means to do nothing depends on what sort of behavior Client is expecting\nwhen there is more than one way to do nothing, more than one NullObject class may be required\n",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Null_Object2-2x.png"
          },
          "example": {
            "text": "    ",
            "image": "    "
          },
          "checkList": "    ",
          "rulesOfThumb": "The Null Object class is often implemented as a Singleton. Since a null object usually does not have any state, its state can't change, so multiple instances are identical. Rather than use multiple identical instances, the system can just use a single instance repeatedly.\nIf some clients expect the null object to do nothing one way and some another, multiple NullObject classes will be required. If the do nothing behavior must be customized at run time, the NullObject class will require pluggable variables so that the client can specify how the null object should do nothing (see the discussion of pluggable adaptors in the Adapter pattern). This may generally be a symptom of the AbstractObject not having a well defined (semantic) interface.\nA Null Object does not transform to become a Real Object. If the object may decide to stop providing do nothing behavior and start providing real behavior, it is not a null object. It may be a real object with a do nothing mode, such as a controller which can switch in and out of read-only mode. If it is a single object which must mutate from a do nothing object to a real one, it should be implemented with the State pattern or perhaps the Proxy pattern. In this case a Null State may be used or the proxy may hold a Null Object.\nThe use of a null object can be similar to that of a Proxy, but the two patterns have different purposes. A proxy provides a level of indirection when accessing a real subject, thus controlling access to the subject. A null collaborator does not hide a real object and control access to it, it replaces the real object. A proxy may eventually mutate to start acting like a real subject. A null object will not mutate to start providing real behavior, it will always provide do nothing behavior.\nA Null Object can be a special case of the Strategy pattern. Strategy specifies several ConcreteStrategy classes as different approaches for accomplishing a task. If one of those approaches is to consistently do nothing, that ConcreteStrategy is a NullObject. For example, a Controller is a View's Strategy for handling input, and NoController is the Strategy that ignores all input.\nA Null Object can be a special case of the State pattern. Normally, each ConcreteState has some do nothing methods because they're not appropriate for that state. In fact, a given method is often implemented to do something useful in most states but to do nothing in at least one state. If a particular ConcreteState implements most of its methods to do nothing or at least give null results, it becomes a do nothing state and as such is a null state.\nA Null Object can be used to allow a Visitor to safely visit a hierarchy and handle the null situation.\nNull Object is a concrete collaborator class that acts as the collaborator for a client which needs one. The null behavior is not designed to be mixed into an object that needs some do nothing behavior. It is designed for a class which delegates to a collaborator all of the behavior that may or may not be do nothing behavior."
        },
        {
          "id": 8,
          "title" :"Observer",
          "intent": "Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\nEncapsulate the core (or common or engine) components in a Subject abstraction, and the variable (or optional or user interface) components in an Observer hierarchy.\nThe 'View' part of Model-View-Controller.",
          "problem": "A large monolithic design does not scale well as new graphing or monitoring requirements are levied.",
          "discussion": "Define an object that is the 'keeper' of the data model and/or business logic (the Subject). Delegate all 'view' functionality to decoupled and distinct Observer objects. Observers register themselves with the Subject as they are created. Whenever the Subject changes, it broadcasts to all registered Observers that it has changed, and each Observer queries the Subject for that subset of the Subject's state that it is responsible for monitoring.\n\nThis allows the number and 'type' of 'view' objects to be configured dynamically, instead of being statically specified at compile-time.\n\nThe protocol described above specifies a 'pull' interaction model. Instead of the Subject 'pushing' what has changed to all Observers, each Observer is responsible for 'pulling' its particular 'window of interest' from the Subject. The 'push' model compromises reuse, while the 'pull' model is less efficient.\n\nIssues that are discussed, but left to the discretion of the designer, include: implementing event compression (only sending a single change broadcast after a series of consecutive changes has occurred), having a single Observer monitoring multiple Subjects, and ensuring that a Subject notify its Observers when it is about to go away.\n\nThe Observer pattern captures the lion's share of the Model-View-Controller architecture that has been a part of the Smalltalk community for years.\n\n",
          "structure": {
            "text": "Subject represents the core (or independent or common or engine) abstraction. Observer represents the variable (or dependent or optional or user interface) abstraction. The Subject prompts the Observer objects to do their thing. Each Observer can call back to the Subject as needed.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Observer-2x.png"
          },
          "example": {
            "text": "The Observer defines a one-to-many relationship so that when one object changes state, the others are notified and updated automatically. Some auctions demonstrate this pattern. Each bidder possesses a numbered paddle that is used to indicate a bid. The auctioneer starts the bidding, and 'observes' when a paddle is raised to accept the bid. The acceptance of the bid changes the bid price which is broadcast to all of the bidders in the form of a new bid.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Observer_example1-2x.png"
          },
          "checkList": "Differentiate between the core (or independent) functionality and the optional (or dependent) functionality.\nModel the independent functionality with a 'subject' abstraction.\nModel the dependent functionality with an 'observer' hierarchy.\nThe Subject is coupled only to the Observer base class.\nThe client configures the number and type of Observers.\nObservers register themselves with the Subject.\nThe Subject broadcasts events to all registered Observers.\nThe Subject may 'push' information at the Observers, or, the Observers may 'pull' the information they need from the Subject.",
          "rulesOfThumb": "Chain of Responsibility, Command, Mediator, and Observer, address how you can decouple senders and receivers, but with different trade-offs. Chain of Responsibility passes a sender request along a chain of potential receivers. Command normally specifies a sender-receiver connection with a subclass. Mediator has senders and receivers reference each other indirectly. Observer defines a very decoupled interface that allows for multiple receivers to be configured at run-time.\nMediator and Observer are competing patterns. The difference between them is that Observer distributes communication by introducing 'observer' and 'subject' objects, whereas a Mediator object encapsulates the communication between other objects. We've found it easier to make reusable Observers and Subjects than to make reusable Mediators.\nOn the other hand, Mediator can leverage Observer for dynamically registering colleagues and communicating with them."
        },
        {
          "id": 9,
          "title" :"State",
          "intent": "Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.\nAn object-oriented state machine\nwrapper + polymorphic wrappee + collaboration",
          "problem": "A monolithic object's behavior is a function of its state, and it must change its behavior at run-time depending on that state. Or, an application is characterized by large and numerous case statements that vector flow of control based on the state of the application.",
          "discussion": "The State pattern is a solution to the problem of how to make behavior depend on state.\n\nDefine a 'context' class to present a single interface to the outside world.\nDefine a State abstract base class.\nRepresent the different 'states' of the state machine as derived classes of the State base class.\nDefine state-specific behavior in the appropriate State derived classes.\nMaintain a pointer to the current 'state' in the 'context' class.\nTo change the state of the state machine, change the current 'state' pointer.\nThe State pattern does not specify where the state transitions will be defined. The choices are two: the 'context' object, or each individual State derived class. The advantage of the latter option is ease of adding new State derived classes. The disadvantage is each State derived class has knowledge of (coupling to) its siblings, which introduces dependencies between subclasses.\n\nA table-driven approach to designing finite state machines does a good job of specifying state transitions, but it is difficult to add actions to accompany the state transitions. The pattern-based approach uses code (instead of data structures) to specify state transitions, but it does a good job of accommodating state transition actions.",
          "structure": {
            "text": "The state machine's interface is encapsulated in the 'wrapper' class. The wrappee hierarchy's interface mirrors the wrapper's interface with the exception of one additional parameter. The extra parameter allows wrappee derived classes to call back to the wrapper class as necessary. Complexity that would otherwise drag down the wrapper class is neatly compartmented and encapsulated in a polymorphic hierarchy to which the wrapper object delegates.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/State1-2x.png"
          },
          "example": {
            "text": "The State pattern allows an object to change its behavior when its internal state changes. This pattern can be observed in a vending machine. Vending machines have states based on the inventory, amount of currency deposited, the ability to make change, the item selected, etc. When currency is deposited and a selection is made, a vending machine will either deliver a product and no change, deliver a product and change, deliver no product due to insufficient currency on deposit, or deliver no product due to inventory depletion.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/State_example1-2x.png"
          },
          "checkList": "Identify an existing class, or create a new class, that will serve as the 'state machine' from the client's perspective. That class is the 'wrapper' class.\nCreate a State base class that replicates the methods of the state machine interface. Each method takes one additional parameter: an instance of the wrapper class. The State base class specifies any useful 'default' behavior.\nCreate a State derived class for each domain state. These derived classes only override the methods they need to override.\nThe wrapper class maintains a 'current' State object.\nAll client requests to the wrapper class are simply delegated to the current State object, and the wrapper object's this pointer is passed.\nThe State methods change the 'current' state in the wrapper object as appropriate.",
          "rulesOfThumb": "State objects are often Singletons.\nFlyweight explains when and how State objects can be shared.\nInterpreter can use State to define parsing contexts.\nStrategy has 2 different implementations, the first is similar to State. The difference is in binding times (Strategy is a bind-once pattern, whereas State is more dynamic).\nThe structure of State and Bridge are identical (except that Bridge admits hierarchies of envelope classes, whereas State allows only one). The two patterns use the same structure to solve different problems: State allows an object's behavior to change along with its state, while Bridge's intent is to decouple an abstraction from its implementation so that the two can vary independently.\nThe implementation of the State pattern builds on the Strategy pattern. The difference between State and Strategy is in the intent. With Strategy, the choice of algorithm is fairly stable. With State, a change in the state of the 'context' object causes it to select from its 'palette' of Strategy objects."
        },
        {
          "id": 10,
          "title" :"Strategy",
          "intent": "Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.\nCapture the abstraction in an interface, bury implementation details in derived classes.\n",
          "problem": "One of the dominant strategies of object-oriented design is the 'open-closed principle'.\n\nFigure demonstrates how this is routinely achieved - encapsulate interface details in a base class, and bury implementation details in derived classes. Clients can then couple themselves to an interface, and not have to experience the upheaval associated with change: no impact when the number of derived classes changes, and no impact when the implementation of a derived class changes. A generic value of the software community for years has been, 'maximize cohesion and minimize coupling'. The object-oriented design approach shown in figure is all about minimizing coupling. Since the client is coupled only to an abstraction (i.e. a useful fiction), and not a particular realization of that abstraction, the client could be said to be practicing 'abstract coupling' . an object-oriented variant of the more generic exhortation 'minimize coupling'.\n\nA more popular characterization of this 'abstract coupling' principle is 'Program to an interface, not an implementation'.\n\nClients should prefer the 'additional level of indirection' that an interface (or an abstract base class) affords. The interface captures the abstraction (i.e. the 'useful fiction') the client wants to exercise, and the implementations of that interface are effectively hidden.",
          "discussion": "    ",
          "structure": {
            "text": "The Interface entity could represent either an abstract base class, or the method signature expectations by the client. In the former case, the inheritance hierarchy represents dynamic polymorphism. In the latter case, the Interface entity represents template code in the client and the inheritance hierarchy represents static polymorphism.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Strategy_-2x.png"
          },
          "example": {
            "text": "A Strategy defines a set of algorithms that can be used interchangeably. Modes of transportation to an airport is an example of a Strategy. Several options exist such as driving one's own car, taking a taxi, an airport shuttle, a city bus, or a limousine service. For some airports, subways and helicopters are also available as a mode of transportation to the airport. Any of these modes of transportation will get a traveler to the airport, and they can be used interchangeably. The traveler must choose the Strategy based on trade-offs between cost, convenience, and time.\n\n",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Strategy_example1-2x.png"
          },
          "checkList": "Identify an algorithm (i.e. a behavior) that the client would prefer to access through a 'flex point'.\nSpecify the signature for that algorithm in an interface.\nBury the alternative implementation details in derived classes.\nClients of the algorithm couple themselves to the interface.",
          "rulesOfThumb": "Strategy is like Template Method except in its granularity.\nState is like Strategy except in its intent.\nStrategy lets you change the guts of an object. Decorator lets you change the skin.\nState, Strategy, Bridge (and to some degree Adapter) have similar solution structures. They all share elements of the 'handle/body' idiom. They differ in intent - that is, they solve different problems.\nStrategy has 2 different implementations, the first is similar to State. The difference is in binding times (Strategy is a bind-once pattern, whereas State is more dynamic).\nStrategy objects often make good Flyweights."
        },
        {
          "id": 11,
          "title" :"Template Method",
          "intent": "Define the skeleton of an algorithm in an operation, deferring some steps to client subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.\nBase class declares algorithm 'placeholders', and derived classes implement the placeholders.\n",
          "problem": "Two different components have significant similarities, but demonstrate no reuse of common interface or implementation. If a change common to both components becomes necessary, duplicate effort must be expended.",
          "discussion": "The component designer decides which steps of an algorithm are invariant (or standard), and which are variant (or customizable). The invariant steps are implemented in an abstract base class, while the variant steps are either given a default implementation, or no implementation at all. The variant steps represent 'hooks', or 'placeholders', that can, or must, be supplied by the component's client in a concrete derived class.\n\nThe component designer mandates the required steps of an algorithm, and the ordering of the steps, but allows the component client to extend or replace some number of these steps.\n\nTemplate Method is used prominently in frameworks. Each framework implements the invariant pieces of a domain's architecture, and defines 'placeholders' for all necessary or interesting client customization options. In so doing, the framework becomes the 'center of the universe', and the client customizations are simply 'the third rock from the sun'. This inverted control structure has been affectionately labelled 'the Hollywood principle' - 'don't call us, we'll call you'.\n\n",
          "structure": {
            "text": "The implementation of template_method() is: call step_one(), call step_two(), and call step_three(). step_two() is a 'hook' method – a placeholder. It is declared in the base class, and then defined in derived classes. Frameworks (large scale reuse infrastructures) use Template Method a lot. All reusable code is defined in the framework's base classes, and then clients of the framework are free to define customizations by creating derived classes as needed.\n\n",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Template_Method-2x.png"
          },
          "example": {
            "text": "The Template Method defines a skeleton of an algorithm in an operation, and defers some steps to subclasses. Home builders use the Template Method when developing a new subdivision. A typical subdivision consists of a limited number of floor plans with different variations available for each. Within a floor plan, the foundation, framing, plumbing, and wiring will be identical for each house. Variation is introduced in the later stages of construction to produce a wider variety of models.\n\nAnother example: daily routine of a worker.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Template_method_example-2x.png"
          },
          "checkList": "Examine the algorithm, and decide which steps are standard and which steps are peculiar to each of the current classes.\nDefine a new abstract base class to host the 'don't call us, we'll call you' framework.\nMove the shell of the algorithm (now called the 'template method') and the definition of all standard steps to the new base class.\nDefine a placeholder or 'hook' method in the base class for each step that requires many different implementations. This method can host a default implementation – or – it can be defined as abstract (Java) or pure virtual (C++).\nInvoke the hook method(s) from the template method.\nEach of the existing classes declares an 'is-a' relationship to the new abstract base class.\nRemove from the existing classes all the implementation details that have been moved to the base class.\nThe only details that will remain in the existing classes will be the implementation details peculiar to each derived class.\n",
          "rulesOfThumb": "Rules of thumb\n\nStrategy is like Template Method except in its granularity.\nTemplate Method uses inheritance to vary part of an algorithm. Strategy uses delegation to vary the entire algorithm.\nStrategy modifies the logic of individual objects. Template Method modifies the logic of an entire class.\nFactory Method is a specialization of Template Method."
        },
        {
          "id": 12,
          "title" :"Visitor",
          "intent": "Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.\nThe classic technique for recovering lost type information.\nDo the right thing based on the type of two objects.\nDouble dispatch",
          "problem": "Many distinct and unrelated operations need to be performed on node objects in a heterogeneous aggregate structure. You want to avoid 'polluting' the node classes with these operations. And, you don't want to have to query the type of each node and cast the pointer to the correct type before performing the desired operation.",
          "discussion": "Visitor's primary purpose is to abstract functionality that can be applied to an aggregate hierarchy of 'element' objects. The approach encourages designing lightweight Element classes - because processing functionality is removed from their list of responsibilities. New functionality can easily be added to the original inheritance hierarchy by creating a new Visitor subclass.\n\nVisitor implements 'double dispatch'. OO messages routinely manifest 'single dispatch' - the operation that is executed depends on: the name of the request, and the type of the receiver. In 'double dispatch', the operation executed depends on: the name of the request, and the type of TWO receivers (the type of the Visitor and the type of the element it visits).\n\nThe implementation proceeds as follows. Create a Visitor class hierarchy that defines a pure virtual visit() method in the abstract base class for each concrete derived class in the aggregate node hierarchy. Each visit() method accepts a single argument - a pointer or reference to an original Element derived class.\n\nEach operation to be supported is modelled with a concrete derived class of the Visitor hierarchy. The visit() methods declared in the Visitor base class are now defined in each derived subclass by allocating the 'type query and cast' code in the original implementation to the appropriate overloaded visit() method.\n\nAdd a single pure virtual accept() method to the base class of the Element hierarchy.  accept() is defined to receive a single argument - a pointer or reference to the abstract base class of the Visitor hierarchy.\n\nEach concrete derived class of the Element hierarchy implements the accept() method by simply calling the visit() method on the concrete derived instance of the Visitor hierarchy that it was passed, passing its 'this' pointer as the sole argument.\n\nEverything for 'elements' and 'visitors' is now set-up. When the client needs an operation to be performed, (s)he creates an instance of the Visitor object, calls the accept() method on each Element object, and passes the Visitor object.\n\nThe accept() method causes flow of control to find the correct Element subclass. Then when the visit() method is invoked, flow of control is vectored to the correct Visitor subclass. accept() dispatch plus visit() dispatch equals double dispatch.\n\nThe Visitor pattern makes adding new operations (or utilities) easy - simply add a new Visitor derived class. But, if the subclasses in the aggregate node hierarchy are not stable, keeping the Visitor subclasses in sync requires a prohibitive amount of effort.\n\nAn acknowledged objection to the Visitor pattern is that is represents a regression to functional decomposition - separate the algorithms from the data structures. While this is a legitimate interpretation, perhaps a better perspective/rationale is the goal of promoting non-traditional behavior to full object status.",
          "structure": {
            "text": "The Element hierarchy is instrumented with a 'universal method adapter'. The implementation of accept() in each Element derived class is always the same. But – it cannot be moved to the Element base class and inherited by all derived classes because a reference to this in the Element class always maps to the base type Element. When the polymorphic firstDispatch() method is called on an abstract First object, the concrete type of that object is 'recovered'. When the polymorphic secondDispatch() method is called on an abstract Second object, its concrete type is 'recovered'. The application functionality appropriate for this pair of types can now be exercised.",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Visitor1-2x.png"
          },
          "example": {
            "text": "The Visitor pattern represents an operation to be performed on the elements of an object structure without changing the classes on which it operates. This pattern can be observed in the operation of a taxi company. When a person calls a taxi company (accepting a visitor), the company dispatches a cab to the customer. Upon entering the taxi the customer, or Visitor, is no longer in control of his or her own transportation, the taxi (driver) is.\n\n",
            "image": "https://sourcemaking.com/files/v2/content/patterns/Visitor_example1-2x.png"
          },
          "checkList": "Confirm that the current hierarchy (known as the Element hierarchy) will be fairly stable and that the public interface of these classes is sufficient for the access the Visitor classes will require. If these conditions are not met, then the Visitor pattern is not a good match.\nCreate a Visitor base class with a visit(ElementXxx) method for each Element derived type.\nAdd an accept(Visitor) method to the Element hierarchy. The implementation in each Element derived class is always the same – accept( Visitor v ) { v.visit( this ); }. Because of cyclic dependencies, the declaration of the Element and Visitor classes will need to be interleaved.\nThe Element hierarchy is coupled only to the Visitor base class, but the Visitor hierarchy is coupled to each Element derived class. If the stability of the Element hierarchy is low, and the stability of the Visitor hierarchy is high; consider swapping the 'roles' of the two hierarchies.\nCreate a Visitor derived class for each 'operation' to be performed on Element objects.  visit() implementations will rely on the Element's public interface.\nThe client creates Visitor objects and passes each to Element objects by calling accept().",
          "rulesOfThumb": "The abstract syntax tree of Interpreter is a Composite (therefore Iterator and Visitor are also applicable).\nIterator can traverse a Composite. Visitor can apply an operation over a Composite.\nThe Visitor pattern is like a more powerful Command pattern because the visitor may initiate whatever is appropriate for the kind of object it encounters.\nThe Visitor pattern is the classic technique for recovering lost type information without resorting to dynamic casts."
        }
      ]
    }
  ]
}